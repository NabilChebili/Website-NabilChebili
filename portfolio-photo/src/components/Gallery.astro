---
const { id = 'gallery', title = 'Gallery', photos = [] } = Astro.props;
---

<section id={id} class="gallery-section">
  <div class="container">
    <div class="section-head">
      <h2 class="section-title">{title}</h2>
      <button class="download-all-btn" type="button" aria-label={`Télécharger toutes les photos de ${title}`}>Télécharger tout</button>
    </div>
    <div class="grid" role="list">
      {photos.map((p, i) => (
        <figure class="photo" style={`--i:${i}`}>
          <img src={p} alt="" loading="lazy" data-section={id} />
        </figure>
      ))}
    </div>
    <div class="lightbox" aria-hidden="true">
      <div class="lb-inner">
        <img src="" alt="" />
        <div class="lb-controls">
          <button class="lb-download" type="button">Télécharger</button>
          <button class="lb-share" type="button">Partager</button>
          <button class="lb-close" type="button" aria-label="Fermer">✕</button>
        </div>
      </div>
    </div>
  </div>

    <script>
      (function () {
        const sections = Array.from(document.querySelectorAll('.gallery-section'));
        sections.forEach((section) => {
            const grid = section.querySelector('.grid');
            const images = Array.from(grid.querySelectorAll('img'));

            // show images only when fully loaded and animate their appearance
            images.forEach((img) => {
              const fig = img.closest('.photo');
              // default placeholder aspect ratio to avoid big layout jumps
              if (fig) fig.style.aspectRatio = '3 / 2';

              function markLoaded() {
                // set accurate aspect-ratio if available
                if (img.naturalWidth && img.naturalHeight && fig) {
                  fig.style.aspectRatio = (img.naturalWidth / img.naturalHeight).toString();
                }
                if (fig) fig.classList.add('is-loaded');
              }

              if (img.complete && img.naturalHeight !== 0) {
                markLoaded();
              } else {
                img.addEventListener('load', markLoaded, { once: true });
              }
            });

            // Using CSS columns for masonry — no JS sizing required. Keep lightbox handlers only.

          // Lightbox
          const lightbox = section.querySelector('.lightbox');
          const lbInner = lightbox.querySelector('.lb-inner');
          const lbImg = lightbox.querySelector('img');
          const lbDownload = lightbox.querySelector('.lb-download');
          const lbShare = lightbox.querySelector('.lb-share');
          const lbClose = lightbox.querySelector('.lb-close');

            // make images keyboard-focusable so we can restore focus on close
            images.forEach((img) => img.setAttribute('tabindex', '0'));

            let lastOpenedImg = null;
            let scrollLock = null;

            images.forEach((img) => {
            img.addEventListener('click', (e) => {
              e.stopPropagation();
              const src = img.currentSrc || img.src;
              lastOpenedImg = img;
              openLightbox(src);
            });
            img.addEventListener('keydown', (e) => {
              if (e.key === 'Enter' || e.key === ' ') {
                e.preventDefault();
                const src = img.currentSrc || img.src;
                lastOpenedImg = img;
                openLightbox(src);
              }
            });
          });

          function lockScroll() {
            const y = window.scrollY || document.documentElement.scrollTop;
            document.body.style.position = 'fixed';
            document.body.style.top = `-${y}px`;
            scrollLock = y;
          }

          function unlockScroll() {
            if (scrollLock !== null) {
              document.body.style.position = '';
              const y = scrollLock;
              document.body.style.top = '';
              window.scrollTo(0, y);
              scrollLock = null;
            }
          }

          function openLightbox(src) {
            lbImg.src = src;
            lightbox.classList.add('active');
            lightbox.setAttribute('aria-hidden', 'false');
            lockScroll();
            // set focus to close button for keyboard users
            lbClose.focus();
          }

          // Zoom state
          let scale = 1;
          let translateX = 0;
          let translateY = 0;
          let isDragging = false;
          let startX = 0;
          let startY = 0;
          let lastTouchDistance = 0;

          function resetZoom() {
            scale = 1;
            translateX = 0;
            translateY = 0;
            updateTransform();
          }

          function updateTransform() {
            lbImg.style.transform = `translate(${translateX}px, ${translateY}px) scale(${scale})`;
            lbImg.style.cursor = scale > 1 ? 'grab' : 'zoom-in';
          }

          function closeLightbox() {
            lightbox.classList.remove('active');
            lightbox.setAttribute('aria-hidden', 'true');
            lbImg.src = '';
            resetZoom();
            unlockScroll();
            // restore focus to the image that opened the lightbox
            try {
              if (lastOpenedImg && typeof lastOpenedImg.focus === 'function') lastOpenedImg.focus({ preventScroll: true });
            } catch (e) {
              /* ignore */
            }
          }

          // Click overlay or close button (only if not zoomed)
          lightbox.addEventListener('click', (e) => {
            if (scale === 1 && (e.target === lightbox || e.target === lbClose)) closeLightbox();
          });
          lbClose.addEventListener('click', closeLightbox);

          // Zoom with mouse wheel (centered)
          lbImg.addEventListener('wheel', (e) => {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.15 : 0.15;
            const newScale = Math.max(1, Math.min(5, scale + delta));
            
            if (newScale === 1) {
              resetZoom();
            } else {
              scale = newScale;
              updateTransform();
            }
          }, { passive: false });

          // Double-click to toggle zoom (centered)
          lbImg.addEventListener('dblclick', (e) => {
            if (scale === 1) {
              scale = 2.5;
              updateTransform();
            } else {
              resetZoom();
            }
          });

          // Drag to pan when zoomed
          lbImg.addEventListener('mousedown', (e) => {
            if (scale > 1) {
              isDragging = true;
              startX = e.clientX - translateX;
              startY = e.clientY - translateY;
              lbImg.style.cursor = 'grabbing';
            }
          });

          document.addEventListener('mousemove', (e) => {
            if (isDragging && scale > 1) {
              translateX = e.clientX - startX;
              translateY = e.clientY - startY;
              updateTransform();
            }
          });

          document.addEventListener('mouseup', () => {
            if (isDragging) {
              isDragging = false;
              lbImg.style.cursor = scale > 1 ? 'grab' : 'zoom-in';
            }
          });

          // Touch gestures (pinch-to-zoom)
          lbImg.addEventListener('touchstart', (e) => {
            if (e.touches.length === 2) {
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              lastTouchDistance = Math.sqrt(dx * dx + dy * dy);
            } else if (e.touches.length === 1 && scale > 1) {
              isDragging = true;
              startX = e.touches[0].clientX - translateX;
              startY = e.touches[0].clientY - translateY;
            }
          });

          lbImg.addEventListener('touchmove', (e) => {
            if (e.touches.length === 2 && lastTouchDistance > 0) {
              e.preventDefault();
              const dx = e.touches[0].clientX - e.touches[1].clientX;
              const dy = e.touches[0].clientY - e.touches[1].clientY;
              const distance = Math.sqrt(dx * dx + dy * dy);
              const scaleDiff = distance / lastTouchDistance;
              const newScale = Math.max(1, Math.min(5, scale * scaleDiff));
              
              if (newScale === 1) {
                resetZoom();
              } else {
                scale = newScale;
                updateTransform();
              }
              lastTouchDistance = distance;
            } else if (e.touches.length === 1 && isDragging && scale > 1) {
              e.preventDefault();
              translateX = e.touches[0].clientX - startX;
              translateY = e.touches[0].clientY - startY;
              updateTransform();
            }
          }, { passive: false });

          lbImg.addEventListener('touchend', (e) => {
            if (e.touches.length === 0) {
              isDragging = false;
              lastTouchDistance = 0;
            }
          });

          // Share button (navigator.share when available, fallback to copy URL)
          lbShare.addEventListener('click', async () => {
            const url = lbImg.src;
            if (navigator.share) {
              try {
                await navigator.share({ title: section.querySelector('.section-title').textContent, url });
              } catch (err) {
                /* user cancelled */
              }
            } else {
              try {
                await navigator.clipboard.writeText(location.origin + url);
                const original = lbShare.textContent;
                lbShare.textContent = 'Copié';
                setTimeout(() => (lbShare.textContent = original), 1400);
              } catch (err) {
                // fallback: open in new tab
                window.open(url, '_blank');
              }
            }
          });

          // Download button: force download with blob fetch and blob URL
          lbDownload.addEventListener('click', async (e) => {
            e.preventDefault();
            const url = lbImg.src;
            if (!url) return;
            lbDownload.disabled = true;
            const originalText = lbDownload.textContent;
            lbDownload.textContent = 'Téléchargement...';
            try {
              const res = await fetch(url);
              if (!res.ok) throw new Error('Fetch failed');
              const blob = await res.blob();
              const filename = url.split('/').pop().split('?')[0] || 'image.jpg';
              const blobUrl = URL.createObjectURL(blob);
              const a = document.createElement('a');
              a.href = blobUrl;
              a.download = filename;
              document.body.appendChild(a);
              a.click();
              a.remove();
              URL.revokeObjectURL(blobUrl);
            } catch (err) {
              console.error('Download failed:', err);
              alert("Impossible de télécharger l'image. Réessayez.");
            } finally {
              lbDownload.disabled = false;
              lbDownload.textContent = originalText;
            }
          });

          document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && lightbox.classList.contains('active')) closeLightbox();
          });

          // Download all button: create zip of all images in this section using JSZip (CDN)
          const downloadAllBtn = section.querySelector('.download-all-btn');
          async function loadScript(url) {
            return new Promise((resolve, reject) => {
              if (window.JSZip) return resolve(window.JSZip);
              const s = document.createElement('script');
              s.src = url;
              s.onload = () => resolve(window.JSZip);
              s.onerror = reject;
              document.head.appendChild(s);
            });
          }

          async function downloadAll() {
            if (!downloadAllBtn) return;
            const imgs = images.map((i) => i.currentSrc || i.src).filter(Boolean);
            if (!imgs.length) return;
            downloadAllBtn.disabled = true;
            const originalText = downloadAllBtn.textContent;
            downloadAllBtn.textContent = 'Préparation...';
            try {
              await loadScript('https://cdn.jsdelivr.net/npm/jszip@3.10.1/dist/jszip.min.js');
              const JSZip = window.JSZip;
              const zip = new JSZip();
              for (let i = 0; i < imgs.length; i++) {
                const url = imgs[i];
                downloadAllBtn.textContent = `Téléchargement ${i + 1}/${imgs.length}`;
                try {
                  const res = await fetch(url);
                  if (!res.ok) throw new Error('Fetch failed');
                  const blob = await res.blob();
                  const name = url.split('/').pop().split('?')[0] || `image-${i + 1}.jpg`;
                  zip.file(name, blob);
                } catch (err) {
                  console.warn('Failed to fetch', url, err);
                }
              }
              downloadAllBtn.textContent = 'Création archive...';
              const content = await zip.generateAsync({ type: 'blob' }, (meta) => {
                const pct = Math.round((meta.percent || 0));
                downloadAllBtn.textContent = `Compression ${pct}%`;
              });
              const sectionId = section.id || 'photos';
              const zipName = `${sectionId}.zip`;
              const url = URL.createObjectURL(content);
              const a = document.createElement('a');
              a.href = url;
              a.download = zipName;
              document.body.appendChild(a);
              a.click();
              a.remove();
              URL.revokeObjectURL(url);
            } catch (err) {
              console.error(err);
              alert('Impossible de créer l’archive. Réessayez ou téléchargez les images individuellement.');
            } finally {
              downloadAllBtn.disabled = false;
              downloadAllBtn.textContent = originalText;
            }
          }

          if (downloadAllBtn) downloadAllBtn.addEventListener('click', downloadAll);
        });
      })();
    </script>
</section>
